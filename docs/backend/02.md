---
title: 什麼是 API？
description: 介紹 API 的基本概念、用途、設計原則，以及 Node.js 與 JavaScript 的關係和事件迴圈機制。
keywords: [API, 應用程式介面, 前端, 後端, 資料交換, 網路協定, RESTful, Web 服務, Node.js, JavaScript, 事件迴圈]
---

## 一、Node.js 與 JavaScript 的關係

### 1\. **JavaScript 的起源與用途**

- **JavaScript** 是一種高階、動態型別的程式語言，最初設計用於在網頁瀏覽器中增加互動性，例如操作網頁元素（如 DOM）、處理用戶輸入等。

- 在瀏覽器中，JavaScript 運行在 V8 引擎（Google Chrome 使用的 JavaScript 引擎）等環境中，負責處理網頁的動態行為。

- 傳統上，JavaScript 只能在瀏覽器中運行，無法直接進行檔案系統操作或網路伺服器管理等後端任務。

### 2\. **Node.js 是什麼？**

- **Node.js** 是一個開源的運行時環境（runtime environment），讓 JavaScript 程式碼可以在瀏覽器之外的地方運行，例如你的電腦或伺服器。

- Node.js 基於 Google 的 V8 引擎，但擴展了 JavaScript 的能力，提供了額外的模組和功能，例如：

  - 檔案系統操作（fs 模組）

  - 網路功能（http 模組，用於建立伺服器）

  - 作業系統相關任務

- 簡單來說，Node.js 讓 JavaScript 從「只能在網頁跑的語言」變成「也能在伺服器端跑的全能語言」。

### 3\. **Node.js 與 JavaScript 的關係**

- **語言與環境的關係**：

  - JavaScript 是程式語言，定義了語法和邏輯（例如變數、函式、迴圈等）。

  - Node.js 是一個運行時環境，提供平台讓 JavaScript 在伺服器端執行，並增加了瀏覽器沒有的功能（例如檔案操作、網路請求）。

- **程式碼相容性**：

  - 你在瀏覽器中學到的 JavaScript 語法（例如 let、const、陣列方法等）在 Node.js 中幾乎都可以直接使用。

  - 但 Node.js 提供了額外的模組（例如 fs、http），這些是瀏覽器環境沒有的。

- **範例比較**：

  - **瀏覽器中的 JavaScript**：

    ```javascript
    document.getElementById("myButton").addEventListener("click", () => {
      alert("你點擊了按鈕！");
    });
    ```

    這段程式碼操作網頁上的按鈕，顯示提示框。

  - **Node.js 中的 JavaScript**：

    ```javascript
    const http = require("http");

    const server = http.createServer((req, res) => {
      res.statusCode = 200;
      res.setHeader("Content-Type", "text/plain");
      res.end("你好，這是一個 Node.js 伺服器！");
    });

    server.listen(3000, () => {
      console.log("伺服器運行在 http://localhost:3000");
    });
    ```

    這段程式碼建立了一個簡單的 HTTP 伺服器，當訪問 http://localhost:3000 時，顯示文字。

### 4\. **Node.js 對前端工程師的意義**

- **全端開發**：你可以用 JavaScript 同時寫前端和後端程式碼，成為全端工程師。

- **工具開發**：許多前端工具（例如 Webpack、Vite、ESLint）都基於 Node.js，理解 Node.js 有助於使用和自訂這些工具。

- **伺服器端邏輯**：Node.js 可用於開發 API、處理檔案等後端任務。

## 二、事件迴圈（Event Loop）在 Node.js 中的作用

### 1\. **什麼是事件迴圈？**

- **事件迴圈（Event Loop）** 是 Node.js 的核心機制，用於處理非同步（asynchronous）操作，讓 JavaScript 雖然是單執行緒（single-threaded）語言，卻能高效處理大量的並行任務，例如網路請求、檔案讀寫、計時器等。

- 簡單來說，事件迴圈就像一個「任務調度員」，負責管理程式中的非同步任務，確保它們在適當的時機執行。

### 2\. **為什麼需要事件迴圈？**

- JavaScript 是單執行緒的，意味著一次只能執行一個任務。如果某個任務（例如讀取大檔案）需要很長時間，會「阻塞」程式，導致其他任務無法執行。

- 事件迴圈解決了這個問題，它將耗時的操作（例如 I/O 操作）交給系統內核或 Node.js 的工作執行緒（worker threads）處理，然後在任務完成時，將結果放回事件佇列（event queue），等待主執行緒執行。

### 3\. **事件迴圈的運作流程**

事件迴圈的運作可以分為以下幾個階段（簡化版）：

1. **計時器（Timers）**：執行 setTimeout 和 setInterval 的回呼函式。

2. **待處理的回呼（Pending Callbacks）**：執行 I/O 操作（例如檔案讀寫、網路請求）的回呼。

3. **閒置階段（Idle, Prepare）**：Node.js 內部用於準備工作。

4. **輪詢（Poll）**：檢查是否有新的 I/O 事件需要處理（例如新進的網路請求）。

5. **檢查（Check）**：執行 setImmediate 的回呼。

6. **關閉回呼（Close Callbacks）**：處理關閉事件（例如關閉檔案或網路連線）。

事件迴圈會不斷循環這些階段，直到沒有任務需要執行。

### 4\. **事件迴圈的簡單範例**

以下是一個簡單的 Node.js 程式，展示事件迴圈如何處理非同步任務：

```javascript
console.log("程式開始");

setTimeout(() => {
  console.log("這是 setTimeout 的回呼，3 秒後執行");
}, 3000);

setImmediate(() => {
  console.log("這是 setImmediate 的回呼，立即執行");
});

console.log("程式結束");
```

**執行結果**：

```
程式開始
程式結束
這是 setImmediate 的回呼，立即執行
這是 setTimeout 的回呼，3 秒後執行
```

**解釋**：

- console.log('程式開始') 和 console.log('程式結束') 是同步程式碼，會立即執行。

- setImmediate 的回呼會在事件迴圈的「檢查」階段執行，因此在同步程式碼執行完後立即運行。

- setTimeout 的回呼會在事件迴圈的「計時器」階段執行，因為設定了 3 秒延遲，所以會在 3 秒後運行。

- 事件迴圈負責管理這些非同步任務的執行順序。
